#![allow(incomplete_features, reason = "This is the only way to make it work")]
#![feature(specialization)]

pub use mlua_gen_macros::mlua_gen;
use {
    mlua::{AnyUserData, FromLua, IntoLua},
    std::ops::{Index, IndexMut},
};

pub trait LuaBuilder<R: IntoLua + FromLua, Lua, E, Table> {
    /// Creates the constructor for a struct or enum.
    ///
    /// For structs, will allow doing:
    /// ```lua
    /// local unit = MyUnitStruct
    /// local unnamed = MyUnnamedStruct(value)
    /// local named = MyNamedStruct { key = value }
    /// ```
    ///
    /// And for enums:
    ///
    /// ```lua
    /// local unit = MyEnum.UnitVariant
    /// local unnamed = MyEnum.Unnamed(value)
    /// local named = MyEnum.Named { key = value }
    /// ```
    fn lua_builder(lua: &Lua) -> Result<R, E>;

    /// Creates the the constructor functions for a struct or enum.
    ///
    /// ### Note
    ///
    /// When used with [LuaBuilder::to_globals], it will register structs functions under `MyStruct_`
    fn lua_fn_builder(lua: &Lua) -> Result<Option<Table>, E>;

    /// Add a struct or enum to the global values of Lua.
    ///
    /// This function creates both enum&struct declaration but also function declaration and
    /// associated data like, field/variant access, methods etc.
    ///
    /// For structs (and not enums) function declaration (like `new`, `default`, etc.), note that
    /// you'll need to use `MyStruct_` when declared as `MyStruct`.
    fn to_globals(lua: &Lua) -> Result<(), E>;

    /// Same as [LuaBuilder::to_globals] but it will register the struct/enum with a custom name
    /// instead of the default Rust name.
    fn to_globals_as<S: AsRef<str>>(lua: &Lua, s: S) -> Result<(), E>;
}

/// Here to conditionnaly check if a type `impl Index<usize>`
#[doc(hidden)]
pub trait IsIndexable {
    const IS_INDEXABLE: bool = false;
    type IndexType: IntoLua;

    /// This method MUST only be called by `mlua-gen` generated code. Calling it from somewhere
    /// else might produce unexpected panics.
    #[doc(hidden)]
    fn index_or_unreachable(&self, _index: usize) -> Self::IndexType {
        unreachable!()
    }
}

impl<T> IsIndexable for T {
    // dummy type
    default type IndexType = u8;

    default const IS_INDEXABLE: bool = false;

    default fn index_or_unreachable(&self, index: usize) -> Self::IndexType {
        unreachable!()
    }
}

impl<T: Index<usize>> IsIndexable for T
where
    <T as Index<usize>>::Output: Sized + 'static + Clone + mlua::IntoLua,
{
    type IndexType = <T as Index<usize>>::Output;

    const IS_INDEXABLE: bool = true;

    fn index_or_unreachable(&self, index: usize) -> Self::IndexType {
        self[index].clone()
    }
}


// Same but with [`IndexMut`]
pub trait IsMutIndexable {
    type IndexType;

    const IS_MUT_INDEXABLE: bool = false;

    #[doc(hidden)]
    fn set_index_or_unreachable(&mut self, _index: usize, _val: Self::IndexType) {
        unreachable!()
    }
}

impl<T> IsMutIndexable for T {
    // dummy type
    default type IndexType = T;

    default const IS_MUT_INDEXABLE: bool = false;

    default fn set_index_or_unreachable(&mut self, _index: usize, _val: Self::IndexType) {
        unreachable!()
    }
}

impl<T: IndexMut<usize>> IsMutIndexable for T
where
    <T as Index<usize>>::Output: Sized + 'static + Clone + mlua::IntoLua,
{
    type IndexType = <T as Index<usize>>::Output;

    const IS_MUT_INDEXABLE: bool = true;

    fn set_index_or_unreachable(&mut self, index: usize, val: Self::IndexType) {
        self[index] = val;
    }
}



/// Here to conditionnaly check if a type was generated by `mlua_gen`
///
/// The reason that we cannot just use `LuaBuilder` is because specialization won't work with
/// generics inside `LuaBuilder` which are needed because of `R` and `E`. Therefore, there is
/// [`mlua_gen::AutomaticImplWhenMluaGen`] which is automatically `impl`ed when using `#[mlua_gen]`
#[doc(hidden)]
pub trait IsMluaGenerated {
    const IS_MLUA_GENERATED: bool = false;
}

impl<T> IsMluaGenerated for T {
    default const IS_MLUA_GENERATED: bool = false;
}

impl<T: AutomaticImplWhenMluaGen> IsMluaGenerated for T {
    const IS_MLUA_GENERATED: bool = true;
}

/// Automatically `impl`ed when using `#[mlua_gen]`
#[doc(hidden)]
pub trait AutomaticImplWhenMluaGen {}

#[macro_export]
macro_rules! to_lua {
    ($lua:ident, $($struct_or_enum:ident),*) => {
        $($struct_or_enum::to_globals(&$lua)?);*
    };
}
