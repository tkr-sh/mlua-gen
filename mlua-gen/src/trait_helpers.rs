use {
    crate::NewIndex,
    mlua::{FromLua, IntoLua},
    std::ops::{Index, IndexMut},
};

/// Here to conditionnaly check if a type `impl Index<usize>`
#[doc(hidden)]
pub trait IsIndexable {
    const IS_INDEXABLE: bool = false;
    type IndexType: IntoLua;

    /// This method MUST only be called by `mlua-gen` generated code. Calling it from somewhere
    /// else might produce unexpected panics.
    #[doc(hidden)]
    fn index_or_unreachable(&self, _index: usize) -> Self::IndexType {
        unreachable!()
    }
}

impl<T> IsIndexable for T {
    // dummy type
    default type IndexType = u8;

    default const IS_INDEXABLE: bool = false;

    default fn index_or_unreachable(&self, index: usize) -> Self::IndexType {
        unreachable!()
    }
}

/// TODO: handle more indexable data types in std
impl<T: Index<usize>> IsIndexable for T
where
    <T as Index<usize>>::Output: Sized + 'static + Clone + mlua::IntoLua,
{
    type IndexType = <T as Index<usize>>::Output;

    const IS_INDEXABLE: bool = true;

    fn index_or_unreachable(&self, index: usize) -> Self::IndexType {
        self[index].clone()
    }
}


// Same but with [`IndexMut`]
pub trait IsMutIndexable {
    type IndexType: FromLua;

    const IS_MUT_INDEXABLE: bool = false;

    #[doc(hidden)]
    fn set_index_or_unreachable(&mut self, _index: usize, _val: Self::IndexType) {
        unreachable!()
    }
}

impl<T> IsMutIndexable for T {
    // dummy type
    default type IndexType = u8;

    default const IS_MUT_INDEXABLE: bool = false;

    default fn set_index_or_unreachable(&mut self, _index: usize, _val: Self::IndexType) {
        unreachable!()
    }
}

impl<T: IndexMut<usize>> IsMutIndexable for T
where
    <T as Index<usize>>::Output: Sized + 'static + Clone + mlua::IntoLua + mlua::FromLua,
{
    type IndexType = <T as Index<usize>>::Output;

    const IS_MUT_INDEXABLE: bool = true;

    fn set_index_or_unreachable(&mut self, index: usize, val: Self::IndexType) {
        self[index] = val;
    }
}

// Same but with [`NewIndex`]
pub trait IsNewIndexable {
    type Key: FromLua;
    type Item: FromLua;

    const IS_NEW_INDEXABLE: bool = false;

    #[doc(hidden)]
    fn set_index_or_unreachable(&mut self, _index: Self::Key, _val: Self::Item) {
        unreachable!()
    }
}

impl<T> IsNewIndexable for T {
    // dummy type
    default type Item = u8;
    default type Key = u8;

    default const IS_NEW_INDEXABLE: bool = false;

    default fn set_index_or_unreachable(&mut self, _index: Self::Key, _val: Self::Item) {
        unreachable!()
    }
}

impl<T: NewIndex> IsNewIndexable for T
where
    <T as NewIndex>::Item: FromLua,
    <T as NewIndex>::Key: FromLua,
{
    type Item = <T as NewIndex>::Item;
    type Key = <T as NewIndex>::Key;

    const IS_NEW_INDEXABLE: bool = true;

    fn set_index_or_unreachable(&mut self, index: Self::Key, item: Self::Item) {
        self.new_index(index.into_rust_index(), item);
    }
}

/// Converts indexes that are `usize` to `usize - 1`, else, changes nothing
trait IntoRustIndex {
    fn into_rust_index(self) -> Self;
}

impl<T> IntoRustIndex for T {
    default fn into_rust_index(self) -> Self {
        self
    }
}

impl IntoRustIndex for usize {
    fn into_rust_index(self) -> Self {
        self - 1
    }
}



/// Here to conditionnaly check if a type was generated by `mlua_gen`
///
/// The reason that we cannot just use `LuaBuilder` is because specialization won't work with
/// generics inside `LuaBuilder` which are needed because of `R` and `E`. Therefore, there is
/// [`mlua_gen::AutomaticImplWhenMluaGen`] which is automatically `impl`ed when using `#[mlua_gen]`
#[doc(hidden)]
pub trait IsMluaGenerated {
    const IS_MLUA_GENERATED: bool = false;
}

impl<T> IsMluaGenerated for T {
    default const IS_MLUA_GENERATED: bool = false;
}

impl<T: AutomaticImplWhenMluaGen> IsMluaGenerated for T {
    const IS_MLUA_GENERATED: bool = true;
}

/// Automatically `impl`ed when using `#[mlua_gen]`
#[doc(hidden)]
pub trait AutomaticImplWhenMluaGen {}
